(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{534:function(t,a,v){"use strict";v.r(a);var _=v(56),s=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),v("p",[t._v("也称作优先队列，这是由于每次返回的都是最大权重或者最小权重的元素。")]),t._v(" "),v("p",[t._v("和插入顺序没有必然联系，只与权重有关。")]),t._v(" "),v("p",[t._v("返回的元素是有序的（没有在返回过程中新增元素的情况下）。")]),t._v(" "),v("p",[t._v("可以用于贪婪算法，外部排序。")]),t._v(" "),v("p",[t._v("有一些简单的实现，简单链表，有序链表，二叉查找树等。")]),t._v(" "),v("p",[t._v("可以快速找出最大值和最小值。")]),t._v(" "),v("h2",{attrs:{id:"二叉堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二叉堆"}},[t._v("#")]),t._v(" 二叉堆")]),t._v(" "),v("p",[t._v("一种特殊的堆，二叉堆是完全二叉树或者近似完全二叉树。")]),t._v(" "),v("p",[t._v("二叉堆满足堆特性：父节点的键值总是保持固定的序关系与任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。")]),t._v(" "),v("p",[t._v("当父节点的键值总是大于或等于任何一个子节点的键值为"),v("code",[t._v("最大堆")]),t._v("，反之则为"),v("code",[t._v("最小堆")]),t._v("。")]),t._v(" "),v("p",[t._v("上滤插入。")]),t._v(" "),v("p",[t._v("下滤删除。")]),t._v(" "),v("h2",{attrs:{id:"d-堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#d-堆"}},[t._v("#")]),t._v(" d-堆")]),t._v(" "),v("h2",{attrs:{id:"左式堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#左式堆"}},[t._v("#")]),t._v(" 左式堆")]),t._v(" "),v("h2",{attrs:{id:"斜堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#斜堆"}},[t._v("#")]),t._v(" 斜堆")]),t._v(" "),v("h2",{attrs:{id:"二项队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二项队列"}},[t._v("#")]),t._v(" 二项队列")]),t._v(" "),v("h2",{attrs:{id:"应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),v("ul",[v("li",[t._v("贪婪算法")]),t._v(" "),v("li",[t._v("外部排序")])])])}),[],!1,null,null,null);a.default=s.exports}}]);