(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{456:function(t,a,s){"use strict";s.r(a);var v=s(43),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆")]),t._v(" "),s("p",[t._v("也称作优先队列，这是由于每次返回的都是最大权重或者最小权重的元素。\n和插入顺序没有必然联系，只与权重有关。")]),t._v(" "),s("p",[t._v("返回的元素是有序的（没有在返回过程中新增元素的情况下）。")]),t._v(" "),s("p",[t._v("可以用于贪婪算法，外部排序。")]),t._v(" "),s("p",[t._v("有一些简单的实现，简单链表，有序链表，二叉查找树等。")]),t._v(" "),s("h2",{attrs:{id:"二叉堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二叉堆"}},[t._v("#")]),t._v(" 二叉堆")]),t._v(" "),s("p",[t._v("一种特殊的堆，二叉堆是完全二叉树或者近似完全二叉树。")]),t._v(" "),s("p",[t._v("二叉堆满足堆特性：父节点的键值总是保持固定的序关系与任何一个子节点的键值，且每个节点的左子树和右子树都是一个二叉堆。")]),t._v(" "),s("p",[t._v("当父节点的键值总是大于或等于任何一个子节点的键值为"),s("code",[t._v("最大堆")]),t._v("，反之则为"),s("code",[t._v("最小堆")]),t._v("。")]),t._v(" "),s("p",[t._v("上滤插入。")]),t._v(" "),s("p",[t._v("下滤删除。")]),t._v(" "),s("h2",{attrs:{id:"d-堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#d-堆"}},[t._v("#")]),t._v(" d-堆")]),t._v(" "),s("h2",{attrs:{id:"左式堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#左式堆"}},[t._v("#")]),t._v(" 左式堆")]),t._v(" "),s("h2",{attrs:{id:"斜堆"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#斜堆"}},[t._v("#")]),t._v(" 斜堆")]),t._v(" "),s("h2",{attrs:{id:"二项队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二项队列"}},[t._v("#")]),t._v(" 二项队列")]),t._v(" "),s("h2",{attrs:{id:"应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),s("ul",[s("li",[t._v("贪婪算法")]),t._v(" "),s("li",[t._v("外部排序")])])])}),[],!1,null,null,null);a.default=_.exports}}]);