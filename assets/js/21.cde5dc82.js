(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{407:function(a,t,r){"use strict";r.r(t);var v=r(45),_=Object(v.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"go-并发机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#go-并发机制"}},[a._v("#")]),a._v(" go 并发机制")]),a._v(" "),r("p",[a._v("在操作系统的内核线程上，go提供了一个特有的两级线程模型。")]),a._v(" "),r("p",[a._v("不要使用共享内存的方式来通信。作为替代，应该以通信为手段来共享内存。")]),a._v(" "),r("p",[a._v("互斥量，条件变量等都是传统的同步方法。")]),a._v(" "),r("p",[a._v("go 不推荐使用共享内存的方式来传递数据，而推荐使用channel。\nchannel主要用于在goroutine之间传递数据，并且保证整个过程的并发安全性。")]),a._v(" "),r("p",[a._v("go的并发机制指的是用于支撑goroutine和channel的底层原理。")]),a._v(" "),r("p",[a._v("go的线程实现模型，有三个必知的核心元素。")]),a._v(" "),r("p",[a._v("M:machine，代表一个内核线程或者称为工作线程。\nP：processor，代表执行一个go代码片段所需要的资源。\nG：goroutine，代表一个go代码片段。")]),a._v(" "),r("p",[a._v("一个G的执行需要PM的支持。PM共同形成一个有效的G的运行环境（内核线程+上下文）。")]),a._v(" "),r("p",[a._v("每个P都会有一个可运行的G队列。该队列中的G会被依次传递给与P关联的M。")]),a._v(" "),r("p",[a._v("PMG都在用户空间。")]),a._v(" "),r("p",[a._v("M 关联一个内核调度实体。")]),a._v(" "),r("p",[a._v("目前go的GC是基于并发的标记-清扫算法的。")]),a._v(" "),r("p",[a._v("可重入函数：保证go函数使用的变量值不会受到外部变量变化的影响，就既可以保证go函数的独立执行，又不用担心正确性受到破坏。\n如果变量不是引用类型，直接作为函数参数传递就可以了。")]),a._v(" "),r("p",[a._v("保证多个G的执行书顺序就是同步。")]),a._v(" "),r("h2",{attrs:{id:"channel"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#channel"}},[a._v("#")]),a._v(" channel")]),a._v(" "),r("p",[a._v("同一时刻，仅有一个goroutine能向channel发送数据，也仅有一个goroutine能从channel接收数据。\nchannel相当于一个先进先出的消息队列。")]),a._v(" "),r("p",[a._v("引用类型的值都需要通过make函数初始化。")]),a._v(" "),r("p",[a._v("make参数大于0的称为缓冲通道，等于0的称为非缓冲通道。")]),a._v(" "),r("h2",{attrs:{id:"同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[a._v("#")]),a._v(" 同步")]),a._v(" "),r("p",[a._v("解锁一个未锁定的锁会造成无法恢复的panic。")]),a._v(" "),r("h3",{attrs:{id:"读写锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读写锁"}},[a._v("#")]),a._v(" 读写锁")]),a._v(" "),r("p",[a._v("读之间不互斥，读写互斥，写写互斥。因此，写解锁会唤醒所有等待读的goroutine，快看那个goroutine不写了，我们可以同时读了，看看它写的啥。但是读解锁只会唤醒一个等待获取该锁的goroutine，快看，那个goroutine不读了，我们一个个读，不要挤，排队。。")]),a._v(" "),r("h3",{attrs:{id:"条件变量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#条件变量"}},[a._v("#")]),a._v(" 条件变量")]),a._v(" "),r("h3",{attrs:{id:"原子操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原子操作"}},[a._v("#")]),a._v(" 原子操作")]),a._v(" "),r("h3",{attrs:{id:"只会执行一次"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#只会执行一次"}},[a._v("#")]),a._v(" 只会执行一次")]),a._v(" "),r("h3",{attrs:{id:"waitgroup"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#waitgroup"}},[a._v("#")]),a._v(" waitgroup")]),a._v(" "),r("h3",{attrs:{id:"临时对象池"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#临时对象池"}},[a._v("#")]),a._v(" 临时对象池")])])}),[],!1,null,null,null);t.default=_.exports}}]);