# 数字

## 机器字长

一般指计算机进行一次整数运算所能处理的二进制数据的位数。

通常也包括数据地址长度。

内存按照字节访问。

相邻机器字的地址相差32位。

## 大端

低位字节占用高地址。网络字节序。

## 小端

低对低，高对高。

## 字节序对比 

数值：0x01234567，
地址是0x100，其中0x0123 是高位字节。符合人类阅读顺序，比如123 是一百二十三，1就是最高位。

[理解字节序](https://www.ruanyifeng.com/blog/2016/11/byte-order.html)

|  大端   | 小端  |数值  |
|  ----  | ----  |----  |
| 0x100  | 0x103 |01|
| 0x101  | 0x102 |23|
| 0x102  | 0x101 |45|
| 0x103  | 0x100 |67|

## 无符号数

直接转换为二进制表示。

无符号的最大值显而易见，在位宽确定的情况下，是2的w次方减一。

最小值是0.

## 有符号数

正数，负数，0。

补码0 只有一种表示。

因此需要用补码表示，有符号位，符号位也有权重。

正数部分按位取反，然后加一就可以得到补码。

|  数值   | 操作  |
|  ----  | ----  |
| 0011000000111001  | 12345的真值 |
| 1100111111000110  | 按位取反 |
| +1  | 加1 |
| 1100111111000111  | 得到补码 |
| 0011000000111000  | 按位取反 |
| +1  | +1 |
| 0011000000111001  | 得到源码 |


有符号的最大值是个正数，而且需要拿出一位作为符号位，因此是2的(w-1)次方减一。
最小值是负的2的(w-1)。这是由于符号位是有权重的，也是参与实际数值的计算的。正数的第一位是0，
因此少了一个最高位的有效值，负数的最高位是有效的，所以后面都跟0是显而易见的。

```
1000
0111
1
1000
```

补码中有两个数的补码是自身，0和绝对值最大的负数。


## 补码求源码

1. 如果补码的符号位为“0”，表示是一个正数，其原码就是补码。
2. 如果补码的符号位为“1”，表示是一个负数，那么求给定的这个补码的补码就是要求的原码。

补码，原码，反码都是有符号的。

使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。


## C 语言中的有符号数和无符号数

模运算和按位运算可以采用无符号数。

其他情况不建议使用。

<<< @/example/c/assemble/lab3.c

当一个有符号数和无符号数比较时，会先转换为无符号数，
可以观察到 有符号的负1比无符号的1大。但是似乎不影响四则运算。

## 四则运算

补码加法可能溢出，正数相加溢出产生进位为1就变成了负数。负数相加进位首位变成0.

除数如果是2的k次方，则可以是被除数进行逻辑右移k位，也就是二进制位丢掉k个低位。


|  右移位数   | 被除数  | 结果|
|  ----  | ----  |----  |
|  0   | 15213  | 15213|
|  1  | 7606.5  | 7606|
|  4   | 950.8125  | 950|
|  8   | 59.4257813  | 59|


<<< @/example/c/assemble/lab4.c
<<< @/example/c/assemble/lab4.s

其中重点是

```
shrl $4,%eax
```

意思是逻辑右移四位。

有符号数的移位需要加上2的k次方减一校准。

## 总结

总的来说，这一节就是整数的表示，浮点数在下一节记录。

计算机内部的整数是用补码表示的。

需要掌握补码和原码的转换，补码的四则运算，以及两个特殊值。

学习了组成原理之后，就可以自己设计一个加法器，乘法器，除法器。

c语言代码会编译成机器指令，被加载到内存，cpu一条条指令读取并执行。