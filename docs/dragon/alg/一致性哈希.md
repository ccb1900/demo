# 一致性哈希算法

## 什么是一致性哈希

### 场景

- 分布式缓存

### 元素

- 真实节点
- 虚拟节点
- 哈希环

### 要求

- 逻辑上是一个环
- 真实节点在环上
- 为了保持平衡性，对真实进行某种规则的转换得到虚拟节点。
- 对应虚拟节点的顺序和真实节点顺序没有关系。
- 根据key获取节点时，需要返回真实节点。
- 每个节点拥有一段区间，一般是左侧的区间。
- 两个节点之间的部分称为区间
- 在节点`[a,b]`之间增加节点 `x` ，`x` 分担节点b的压力，也就是在 hash(a) 和 hash(x)之间的哈希值由节点x负担。
- 真实节点与虚拟节点具有同等地位，真实节点删除，对应的虚拟节点也要删除，添加新节点同理。
- 最大的好处是节点的增加与删除影响的范围可以最小化，只会把压力转移到临近的节点。当然，也有可能引起蝴蝶效应雪崩，但是可以通过虚拟节点保持相对均匀的分布，多个节点分担节点变更的压力。

## 实现方式

源码在 `example/go`，进入`example/go/consistent_hash/hash`执行`go test`。

当我们拿到一个 key，首先需要计算她的哈希值，然后与节点的哈希值进行比较，查看是否落在相应的区间。

### 一致性哈希实现

<<< @/example/go/consistent_hash/hash/hash.go

### 哈希接口

可以支持不同的哈希实现

<<< @/example/go/consistent_hash/hash/hash_func.go

### 测试

<<< @/example/go/consistent_hash/hash/hash_test.go

### 实现哈希接口

一种哈希实现，伟大的质数。

<<< @/example/go/consistent_hash/md5/md5.go

### 有序 map 实现(key有序)

显然环上的节点是有序的。golang的map实现是无序的，因此需要以下代码。

此处只是一种简单实现。

使用有序map，可以获取方便的获取有序的自map，这个很重要。

<<< @/example/go/consistent_hash/sortedmap/sorted_map.go