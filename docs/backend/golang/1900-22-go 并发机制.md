# go 并发机制

在操作系统的内核线程上，go提供了一个特有的两级线程模型。

不要使用共享内存的方式来通信。作为替代，应该以通信为手段来共享内存。

互斥量，条件变量等都是传统的同步方法。

go 不推荐使用共享内存的方式来传递数据，而推荐使用channel。
channel主要用于在goroutine之间传递数据，并且保证整个过程的并发安全性。

go的并发机制指的是用于支撑goroutine和channel的底层原理。

go的线程实现模型，有三个必知的核心元素。

M:machine，代表一个内核线程或者称为工作线程。
P：processor，代表执行一个go代码片段所需要的资源。
G：goroutine，代表一个go代码片段。

一个G的执行需要PM的支持。PM共同形成一个有效的G的运行环境（内核线程+上下文）。

每个P都会有一个可运行的G队列。该队列中的G会被依次传递给与P关联的M。

PMG都在用户空间。

M 关联一个内核调度实体。

目前go的GC是基于并发的标记-清扫算法的。

可重入函数：保证go函数使用的变量值不会受到外部变量变化的影响，就既可以保证go函数的独立执行，又不用担心正确性受到破坏。
如果变量不是引用类型，直接作为函数参数传递就可以了。

保证多个G的执行书顺序就是同步。

## channel

同一时刻，仅有一个goroutine能向channel发送数据，也仅有一个goroutine能从channel接收数据。
channel相当于一个先进先出的消息队列。

引用类型的值都需要通过make函数初始化。

make参数大于0的称为缓冲通道，等于0的称为非缓冲通道。

## 同步

解锁一个未锁定的锁会造成无法恢复的panic。

### 读写锁

读之间不互斥，读写互斥，写写互斥。因此，写解锁会唤醒所有等待读的goroutine，快看那个goroutine不写了，我们可以同时读了，看看它写的啥。但是读解锁只会唤醒一个等待获取该锁的goroutine，快看，那个goroutine不读了，我们一个个读，不要挤，排队。。

### 条件变量

### 原子操作

### 只会执行一次

### waitgroup

### 临时对象池



