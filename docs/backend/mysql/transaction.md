# 事务

## 隔离机制

### 未提交读

在事务之间提供最低保护的隔离级别。查询采用锁定策略，允许它们在正常情况下等待另一个事务的情况下继续进行。但是，这种额外的性能是以不太可靠的结果为代价的，包括已被其他事务更改但尚未提交的数据(称为脏读)。请非常谨慎地使用此隔离级别，并注意结果可能不一致或不可重现，这取决于其他事务同时执行的操作。通常，具有此隔离级别的事务只执行查询，而不执行插入、更新或删除操作。

### 已提交读

一种隔离级别，它使用锁定策略来放松事务之间的某些保护，以提高性能。
事务不能看到来自其他事务的未提交数据，但它们可以看到当前事务启动后由另一个事务提交的数据。
因此，事务永远不会看到任何坏数据，但是它看到的数据在某种程度上可能取决于其他事务的时间。

当具有此隔离级别的事务执行“UPDATE...WHERE”或“DELETE...WHERE”操作时，其他事务可能必须等待。
事务可以执行“SELECT...FOR UPDATE”和“LOCK IN SHARE MODE”操作，而不会让其他事务等待。

“SELECT...FOR SHARE”取代了MySQL 8.0.1中的“SELECT...LOCK IN SHARE MODE”，但为了向后兼容，“LOCK IN SHARE MODE”仍然可用。

### 可重复读

可重复读取，但不能进行幻影读取。它使用适度严格的锁定策略，以便事务内的所有查询都能看到来自相同快照的数据，也就是说，数据与事务启动时的数据相同。

当具有此隔离级别的事务执行“UPDATE...WHERE，DELETE...WHERE，SELECT...FOR UPDATE”和“LOCK IN SHARE MODE”操作时，其他事务可能必须等待。

“SELECT...FOR SHARE”取代了MySQL 8.0.1中的“SELECT...LOCK IN SHARE MODE”，但为了向后兼容，“LOCK IN SHARE MODE”仍然可用。

### 序列化

使用最保守的锁定策略的隔离级别，以防止任何其他事务插入或更改此事务读取的数据，直到它完成。这样，可以在事务内反复运行相同的查询，并确保每次都检索相同的结果集。任何更改自当前事务开始以来由另一个事务提交的数据的尝试都会导致当前事务等待。

这是SQL标准指定的默认隔离级别。在实践中，很少需要这种严格程度，因此InnoDB的默认隔离级别是下一个最严格的、可重复的读取。

## 现象

### 脏读

检索不可靠数据的操作，即由另一个事务更新但尚未提交的数据。只有在称为未提交读取的隔离级别下会出现。

这种操作不符合数据库设计的ACID原则。这被认为是非常危险的，因为数据在提交之前可能会被回滚或进一步更新；然后，执行脏读操作的事务将使用从未确认为准确的数据。

它的对立面是一致读取，在这种情况下，InnoDB确保一个事务不读取由另一个事务更新的信息，即使另一个事务同时提交。

### 一致性读

一种读取操作，它使用快照信息根据时间点显示查询结果，而不考虑同时运行的其他事务执行的更改。如果查询的数据已被另一个事务更改，则根据撤消日志的内容重建原始数据。此技术通过强制事务等待其他事务完成，避免了某些可能降低并发性的锁定问题。

使用可重复读取隔离级别时，快照基于执行第一次读取操作的时间。使用已提交读取隔离级别，快照将重置为每次一致读取操作的时间。

一致读取是InnoDB处理READ COMMITTED和REPEATABLE READ隔离级别SELECT语句的默认模式。因为一致读取不会对其访问的表设置任何锁，所以在对表执行一致读取时，其他会话可以自由修改这些表。

### 不可重复读

当一个查询检索数据，而同一事务中稍后的查询检索本应相同的数据，但查询返回不同的结果(由同时提交的另一个事务更改)的情况。

这种操作与数据库设计的ACID原则背道而驰。在事务内，数据应该是一致的，具有可预测和稳定的关系。

在不同的隔离级别中，可序列化读取和可重复读取级别阻止不可重复读取，一致读取和读取未提交级别允许不可重复读取。

### 幻读

出现在查询的结果集中，但不出现在较早查询的结果集中的行。例如，如果一个查询在一个事务内运行两次，并且在此期间，另一个事务在插入新行或更新行之后提交，以使其与查询的WHERE子句相匹配。

这种情况称为幻影读取。它比不可重复读取更难防范，因为锁定第一个查询结果集中的所有行并不能阻止导致幻影出现的更改。

在不同的隔离级别中，可序列化读取级别阻止幻影读取，可重复读取、一致读取和未提交读取级别允许幻影读取。