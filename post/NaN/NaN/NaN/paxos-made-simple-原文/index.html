<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Paxos Made Simple | 献给新一代的文档</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="ico" href="/pages/logo.png">
    <meta name="description" content="java,mysql,php,redis,消息队列,laravel,spring">
    <link rel="preload" href="/pages/assets/css/0.styles.b303da3d.css" as="style"><link rel="preload" href="/pages/assets/js/app.120c2d51.js" as="script"><link rel="preload" href="/pages/assets/js/7.8965607c.js" as="script"><link rel="preload" href="/pages/assets/js/1.14ff8b03.js" as="script"><link rel="preload" href="/pages/assets/js/47.f2cf7598.js" as="script"><link rel="prefetch" href="/pages/assets/js/10.ca1643d2.js"><link rel="prefetch" href="/pages/assets/js/11.63ac0c09.js"><link rel="prefetch" href="/pages/assets/js/12.240e6778.js"><link rel="prefetch" href="/pages/assets/js/13.6ff6f760.js"><link rel="prefetch" href="/pages/assets/js/14.c0efa981.js"><link rel="prefetch" href="/pages/assets/js/15.b7a7561a.js"><link rel="prefetch" href="/pages/assets/js/16.ec833b42.js"><link rel="prefetch" href="/pages/assets/js/17.ceb6a9ad.js"><link rel="prefetch" href="/pages/assets/js/18.9ca07f6f.js"><link rel="prefetch" href="/pages/assets/js/19.44ea52c7.js"><link rel="prefetch" href="/pages/assets/js/20.6702cb9e.js"><link rel="prefetch" href="/pages/assets/js/21.719376e9.js"><link rel="prefetch" href="/pages/assets/js/22.1fbf2732.js"><link rel="prefetch" href="/pages/assets/js/23.d0a15046.js"><link rel="prefetch" href="/pages/assets/js/24.384e1225.js"><link rel="prefetch" href="/pages/assets/js/25.6052cdf4.js"><link rel="prefetch" href="/pages/assets/js/26.de078b05.js"><link rel="prefetch" href="/pages/assets/js/27.2617fd9b.js"><link rel="prefetch" href="/pages/assets/js/28.c005b99b.js"><link rel="prefetch" href="/pages/assets/js/29.a1626a24.js"><link rel="prefetch" href="/pages/assets/js/30.9b50b86e.js"><link rel="prefetch" href="/pages/assets/js/31.7cdcb2a4.js"><link rel="prefetch" href="/pages/assets/js/32.2d00dc23.js"><link rel="prefetch" href="/pages/assets/js/33.e5055c4c.js"><link rel="prefetch" href="/pages/assets/js/34.49f5a84e.js"><link rel="prefetch" href="/pages/assets/js/35.2c74124e.js"><link rel="prefetch" href="/pages/assets/js/36.e7fab114.js"><link rel="prefetch" href="/pages/assets/js/37.50d5698c.js"><link rel="prefetch" href="/pages/assets/js/38.412244e9.js"><link rel="prefetch" href="/pages/assets/js/39.4dea2aed.js"><link rel="prefetch" href="/pages/assets/js/4.2a85abca.js"><link rel="prefetch" href="/pages/assets/js/40.4a0b4cba.js"><link rel="prefetch" href="/pages/assets/js/41.d13414be.js"><link rel="prefetch" href="/pages/assets/js/42.d629bb23.js"><link rel="prefetch" href="/pages/assets/js/43.7c72733c.js"><link rel="prefetch" href="/pages/assets/js/44.f4edf907.js"><link rel="prefetch" href="/pages/assets/js/45.d451b0ee.js"><link rel="prefetch" href="/pages/assets/js/46.fbf46ce3.js"><link rel="prefetch" href="/pages/assets/js/48.93c4ef84.js"><link rel="prefetch" href="/pages/assets/js/49.4c19d133.js"><link rel="prefetch" href="/pages/assets/js/5.427a4bdf.js"><link rel="prefetch" href="/pages/assets/js/50.38e6a8f2.js"><link rel="prefetch" href="/pages/assets/js/51.aefa85da.js"><link rel="prefetch" href="/pages/assets/js/52.80adf99e.js"><link rel="prefetch" href="/pages/assets/js/53.570a0bc6.js"><link rel="prefetch" href="/pages/assets/js/54.7c8f3b58.js"><link rel="prefetch" href="/pages/assets/js/55.a3dbaa70.js"><link rel="prefetch" href="/pages/assets/js/56.afc7a01c.js"><link rel="prefetch" href="/pages/assets/js/57.8763a1ac.js"><link rel="prefetch" href="/pages/assets/js/58.a04ff036.js"><link rel="prefetch" href="/pages/assets/js/59.9c1b3c98.js"><link rel="prefetch" href="/pages/assets/js/6.2a18c0f3.js"><link rel="prefetch" href="/pages/assets/js/60.c8ee3fb0.js"><link rel="prefetch" href="/pages/assets/js/61.75aeb88c.js"><link rel="prefetch" href="/pages/assets/js/62.9427e5ed.js"><link rel="prefetch" href="/pages/assets/js/63.708f8319.js"><link rel="prefetch" href="/pages/assets/js/64.636be464.js"><link rel="prefetch" href="/pages/assets/js/65.61e4d9df.js"><link rel="prefetch" href="/pages/assets/js/66.2df6f298.js"><link rel="prefetch" href="/pages/assets/js/67.c995cf13.js"><link rel="prefetch" href="/pages/assets/js/68.90567252.js"><link rel="prefetch" href="/pages/assets/js/69.68fb6146.js"><link rel="prefetch" href="/pages/assets/js/8.cb12b21f.js"><link rel="prefetch" href="/pages/assets/js/9.42673838.js"><link rel="prefetch" href="/pages/assets/js/vuejs-paginate.d4ef26f8.js">
    <link rel="stylesheet" href="/pages/assets/css/0.styles.b303da3d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/pages/" class="home-link router-link-active"><!----> <span class="site-name">献给新一代的文档</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/pages/backend/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/pages/front/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/pages/dragon/" class="nav-link">
  屠龙术
</a></div><div class="nav-item"><a href="/pages/other/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/pages/recipe/" class="nav-link">
  菜谱
</a></div><div class="nav-item"><a href="/pages/post/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="https://github.com/ccb1900/pages" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/pages/backend/" class="nav-link">
  后端
</a></div><div class="nav-item"><a href="/pages/front/" class="nav-link">
  前端
</a></div><div class="nav-item"><a href="/pages/dragon/" class="nav-link">
  屠龙术
</a></div><div class="nav-item"><a href="/pages/other/" class="nav-link">
  其他
</a></div><div class="nav-item"><a href="/pages/recipe/" class="nav-link">
  菜谱
</a></div><div class="nav-item"><a href="/pages/post/" class="nav-link router-link-active">
  博客
</a></div><div class="nav-item"><a href="https://github.com/ccb1900/pages" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="paxos-made-simple"><a href="#paxos-made-simple" class="header-anchor">#</a> Paxos Made Simple</h1> <p>Leslie Lamport</p> <p>01 Nov 2001</p> <h2 id="abstract"><a href="#abstract" class="header-anchor">#</a> Abstract</h2> <p>The Paxos algorithm, when presented in plain English, is very simple.</p> <h2 id="introduction"><a href="#introduction" class="header-anchor">#</a> Introduction</h2> <p>The Paxos algorithm for implementing a fault-tolerant distributed system
has been regarded as difficult to understand, perhaps because the original
presentation was Greek to many readers [5]. In fact, it is among the simplest and most obvious of distributed algorithms. At its heart is a consensus
algorithm—the “synod” algorithm of [5]. The next section shows that this
consensus algorithm follows almost unavoidably from the properties we want
it to satisfy. The last section explains the complete Paxos algorithm, which
is obtained by the straightforward application of consensus to the state machine approach for building a distributed system—an approach that should
be well-known, since it is the subject of what is probably the most often-cited
article on the theory of distributed systems [4].</p> <h2 id="the-consensus-algorithm"><a href="#the-consensus-algorithm" class="header-anchor">#</a> The Consensus Algorithm</h2> <h3 id="_2-1-the-problem"><a href="#_2-1-the-problem" class="header-anchor">#</a> 2.1. The Problem</h3> <p>Assume a collection of processes that can propose values. A consensus algorithm ensures that a single one among the proposed values is chosen. If
no value is proposed, then no value should be chosen. If a value has been
chosen, then processes should be able to learn the chosen value. The safety
requirements for consensus are:</p> <ul><li>Only a value that has been proposed may be chosen,</li> <li>Only a single value is chosen, and</li> <li>A process never learns that a value has been chosen unless it actually
has been.</li></ul> <p>We won’t try to specify precise liveness requirements. However, the goal is
to ensure that some proposed value is eventually chosen and, if a value has
been chosen, then a process can eventually learn the value.
We let the three roles in the consensus algorithm be performed by three
classes of agents: <code>proposers</code>, <code>acceptors</code>, and <code>learners</code>. In an implementation,
a single process may act as more than one agent, but the mapping from
agents to processes does not concern us here.
Assume that agents can communicate with one another by sending messages. We use the customary asynchronous, non-Byzantine model, in which:</p> <ul><li>Agents operate at arbitrary speed, may fail by stopping, and may
restart. Since all agents may fail after a value is chosen and then
restart, a solution is impossible unless some information can be remembered by an agent that has failed and restarted.</li> <li>Messages can take arbitrarily long to be delivered, can be duplicated,
and can be lost, but they are not corrupted.</li></ul> <h3 id="_2-2-choosing-a-value"><a href="#_2-2-choosing-a-value" class="header-anchor">#</a> 2.2. Choosing a Value</h3> <p>The easiest way to choose a value is to have a single acceptor agent. A proposer sends a proposal to the acceptor, who chooses the first proposed value
that it receives. Although simple, this solution is unsatisfactory because the
failure of the acceptor makes any further progress impossible.
So, let’s try another way of choosing a value. Instead of a single acceptor,
let’s use multiple acceptor agents. A proposer sends a proposed value to a
set of acceptors. An acceptor may accept the proposed value. The value is
chosen when a large enough set of acceptors have accepted it. How large is
large enough? To ensure that only a single value is chosen, we can let a large
enough set consist of any majority of the agents. Because any two majorities
have at least one acceptor in common, this works if an acceptor can accept
at most one value. (There is an obvious generalization of a majority that
has been observed in numerous papers, apparently starting with [3].)
In the absence of failure or message loss, we want a value to be chosen
even if only one value is proposed by a single proposer. This suggests the
requirement:
P1. An acceptor must accept the first proposal that it receives.
But this requirement raises a problem. Several values could be proposed by
different proposers at about the same time, leading to a situation in which
every acceptor has accepted a value, but no single value is accepted by a
majority of them. Even with just two proposed values, if each is accepted by
about half the acceptors, failure of a single acceptor could make it impossible
to learn which of the values was chosen.
P1 and the requirement that a value is chosen only when it is accepted
by a majority of acceptors imply that an acceptor must be allowed to accept
more than one proposal. We keep track of the different proposals that an
acceptor may accept by assigning a (natural) number to each proposal, so a
proposal consists of a proposal number and a value. To prevent confusion,
we require that different proposals have different numbers. How this is
achieved depends on the implementation, so for now we just assume it. A
value is chosen when a single proposal with that value has been accepted by
a majority of the acceptors. In that case, we say that the proposal (as well
as its value) has been chosen.
We can allow multiple proposals to be chosen, but we must guarantee
that all chosen proposals have the same value. By induction on the proposal
number, it suffices to guarantee:
P2. If a proposal with value v is chosen, then every higher-numbered proposal that is chosen has value v.
Since numbers are totally ordered, condition P2 guarantees the crucial safety
property that only a single value is chosen.
To be chosen, a proposal must be accepted by at least one acceptor. So,
we can satisfy P2 by satisfying:
P2a
. If a proposal with value v is chosen, then every higher-numbered proposal accepted by any acceptor has value v.
We still maintain P1 to ensure that some proposal is chosen. Because communication is asynchronous, a proposal could be chosen with some particular acceptor c never having received any proposal. Suppose a new proposer
“wakes up” and issues a higher-numbered proposal with a different value.
P1 requires c to accept this proposal, violating P2a
. Maintaining both P1
and P2a
requires strengthening P2a
to:
P2b
. If a proposal with value v is chosen, then every higher-numbered proposal issued by any proposer has value v.
Since a proposal must be issued by a proposer before it can be accepted by
an acceptor, P2b
implies P2a
, which in turn implies P2.
To discover how to satisfy P2b
, let’s consider how we would prove that
it holds. We would assume that some proposal with number m and value
v is chosen and show that any proposal issued with number n &gt; m also
has value v. We would make the proof easier by using induction on n,
so we can prove that proposal number n has value v under the additional
assumption that every proposal issued with a number in m . .(n − 1) has
value v, where i . . j denotes the set of numbers from i through j. For the
proposal numbered m to be chosen, there must be some set C consisting of a
majority of acceptors such that every acceptor in C accepted it. Combining
this with the induction assumption, the hypothesis that m is chosen implies:</p> <p>Every acceptor in C has accepted a proposal with number in
m . .(n − 1), and every proposal with number in m . .(n − 1)
accepted by any acceptor has value v.
Since any set S consisting of a majority of acceptors contains at least one
member of C , we can conclude that a proposal numbered n has value v by
ensuring that the following invariant is maintained:
P2c
. For any v and n, if a proposal with value v and number n is issued,
then there is a set S consisting of a majority of acceptors such that
either (a) no acceptor in S has accepted any proposal numbered less
than n, or (b) v is the value of the highest-numbered proposal among
all proposals numbered less than n accepted by the acceptors in S.
We can therefore satisfy P2b by maintaining the invariance of P2c
.
To maintain the invariance of P2c
, a proposer that wants to issue a proposal numbered n must learn the highest-numbered proposal with number
less than n, if any, that has been or will be accepted by each acceptor in
some majority of acceptors. Learning about proposals already accepted is
easy enough; predicting future acceptances is hard. Instead of trying to predict the future, the proposer controls it by extracting a promise that there
won’t be any such acceptances. In other words, the proposer requests that
the acceptors not accept any more proposals numbered less than n. This
leads to the following algorithm for issuing proposals.</p> <ol><li>A proposer chooses a new proposal number n and sends a request to
each member of some set of acceptors, asking it to respond with:
(a) A promise never again to accept a proposal numbered less than
n, and
(b) The proposal with the highest number less than n that it has
accepted, if any.
I will call such a request a prepare request with number n.</li> <li>If the proposer receives the requested responses from a majority of
the acceptors, then it can issue a proposal with number n and value
v, where v is the value of the highest-numbered proposal among the
responses, or is any value selected by the proposer if the responders
reported no proposals.</li></ol> <p>A proposer issues a proposal by sending, to some set of acceptors, a request
that the proposal be accepted. (This need not be the same set of acceptors
that responded to the initial requests.) Let’s call this an accept request.
This describes a proposer’s algorithm. What about an acceptor? It can
receive two kinds of requests from proposers: prepare requests and accept
requests. An acceptor can ignore any request without compromising safety.
So, we need to say only when it is allowed to respond to a request. It can
always respond to a prepare request. It can respond to an accept request,
accepting the proposal, iff it has not promised not to. In other words:
P1a
. An acceptor can accept a proposal numbered n iff it has not responded
to a prepare request having a number greater than n.
Observe that P1a
subsumes P1.
We now have a complete algorithm for choosing a value that satisfies the
required safety properties—assuming unique proposal numbers. The final
algorithm is obtained by making one small optimization.
Suppose an acceptor receives a prepare request numbered n, but it has
already responded to a prepare request numbered greater than n, thereby
promising not to accept any new proposal numbered n. There is then no
reason for the acceptor to respond to the new prepare request, since it will
not accept the proposal numbered n that the proposer wants to issue. So
we have the acceptor ignore such a prepare request. We also have it ignore
a prepare request for a proposal it has already accepted.
With this optimization, an acceptor needs to remember only the highestnumbered proposal that it has ever accepted and the number of the highestnumbered prepare request to which it has responded. Because P2c must
be kept invariant regardless of failures, an acceptor must remember this
information even if it fails and then restarts. Note that the proposer can
always abandon a proposal and forget all about it—as long as it never tries
to issue another proposal with the same number.
Putting the actions of the proposer and acceptor together, we see that
the algorithm operates in the following two phases.
Phase 1. (a) A proposer selects a proposal number n and sends a prepare
request with number n to a majority of acceptors.
(b) If an acceptor receives a prepare request with number n greater
than that of any prepare request to which it has already responded,
then it responds to the request with a promise not to accept any more
proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.</p> <p>Phase 2. (a) If the proposer receives a response to its prepare requests
(numbered n) from a majority of acceptors, then it sends an accept
request to each of those acceptors for a proposal numbered n with a
value v, where v is the value of the highest-numbered proposal among
the responses, or is any value if the responses reported no proposals.
(b) If an acceptor receives an accept request for a proposal numbered
n, it accepts the proposal unless it has already responded to a prepare
request having a number greater than n.
A proposer can make multiple proposals, so long as it follows the algorithm
for each one. It can abandon a proposal in the middle of the protocol at any
time. (Correctness is maintained, even though requests and/or responses
for the proposal may arrive at their destinations long after the proposal
was abandoned.) It is probably a good idea to abandon a proposal if some
proposer has begun trying to issue a higher-numbered one. Therefore, if an
acceptor ignores a prepare or accept request because it has already received
a prepare request with a higher number, then it should probably inform
the proposer, who should then abandon its proposal. This is a performance
optimization that does not affect correctness.</p> <h3 id="_2-3-learning-a-chosen-value"><a href="#_2-3-learning-a-chosen-value" class="header-anchor">#</a> 2.3. Learning a Chosen Value</h3> <p>To learn that a value has been chosen, a learner must find out that a proposal has been accepted by a majority of acceptors. The obvious algorithm
is to have each acceptor, whenever it accepts a proposal, respond to all
learners, sending them the proposal. This allows learners to find out about
a chosen value as soon as possible, but it requires each acceptor to respond
to each learner—a number of responses equal to the product of the number
of acceptors and the number of learners.
The assumption of non-Byzantine failures makes it easy for one learner
to find out from another learner that a value has been accepted. We can
have the acceptors respond with their acceptances to a distinguished learner,
which in turn informs the other learners when a value has been chosen. This
approach requires an extra round for all the learners to discover the chosen
value. It is also less reliable, since the distinguished learner could fail. But
it requires a number of responses equal only to the sum of the number of
acceptors and the number of learners.
More generally, the acceptors could respond with their acceptances to
some set of distinguished learners, each of which can then inform all the
learners when a value has been chosen. Using a larger set of distinguished
learners provides greater reliability at the cost of greater communication
complexity.
Because of message loss, a value could be chosen with no learner ever
finding out. The learner could ask the acceptors what proposals they have
accepted, but failure of an acceptor could make it impossible to know whether
or not a majority had accepted a particular proposal. In that case, learners
will find out what value is chosen only when a new proposal is chosen. If
a learner needs to know whether a value has been chosen, it can have a
proposer issue a proposal, using the algorithm described above.</p> <h3 id="_2-4-progress"><a href="#_2-4-progress" class="header-anchor">#</a> 2.4 Progress</h3> <p>It’s easy to construct a scenario in which two proposers each keep issuing
a sequence of proposals with increasing numbers, none of which are ever
chosen. Proposer p completes phase 1 for a proposal number n1. Another
proposer q then completes phase 1 for a proposal number n2 &gt; n1. Proposer
p’s phase 2 accept requests for a proposal numbered n1 are ignored because
the acceptors have all promised not to accept any new proposal numbered
less than n2. So, proposer p then begins and completes phase 1 for a new
proposal number n3 &gt; n2, causing the second phase 2 accept requests of
proposer q to be ignored. And so on.
To guarantee progress, a distinguished proposer must be selected as the
only one to try issuing proposals. If the distinguished proposer can communicate successfully with a majority of acceptors, and if it uses a proposal
with number greater than any already used, then it will succeed in issuing a
proposal that is accepted. By abandoning a proposal and trying again if it
learns about some request with a higher proposal number, the distinguished
proposer will eventually choose a high enough proposal number.
If enough of the system (proposer, acceptors, and communication network) is working properly, liveness can therefore be achieved by electing a
single distinguished proposer. The famous result of Fischer, Lynch, and Patterson [1] implies that a reliable algorithm for electing a proposer must use
either randomness or real time—for example, by using timeouts. However,
safety is ensured regardless of the success or failure of the election.</p> <h3 id="_2-5-the-implementation"><a href="#_2-5-the-implementation" class="header-anchor">#</a> 2.5 The Implementation</h3> <p>The Paxos algorithm [5] assumes a network of processes. In its consensus
algorithm, each process plays the role of proposer, acceptor, and learner.
The algorithm chooses a leader, which plays the roles of the distinguished
proposer and the distinguished learner. The Paxos consensus algorithm is
precisely the one described above, where requests and responses are sent as
ordinary messages. (Response messages are tagged with the corresponding
proposal number to prevent confusion.) Stable storage, preserved during
failures, is used to maintain the information that the acceptor must remember. An acceptor records its intended response in stable storage before
actually sending the response.
All that remains is to describe the mechanism for guaranteeing that no
two proposals are ever issued with the same number. Different proposers
choose their numbers from disjoint sets of numbers, so two different proposers never issue a proposal with the same number. Each proposer remembers (in stable storage) the highest-numbered proposal it has tried to issue,
and begins phase 1 with a higher proposal number than any it has already
used.</p> <h2 id="_3-implementing-a-state-machine"><a href="#_3-implementing-a-state-machine" class="header-anchor">#</a> 3 Implementing a State Machine</h2> <p>A simple way to implement a distributed system is as a collection of clients
that issue commands to a central server. The server can be described as
a deterministic state machine that performs client commands in some sequence. The state machine has a current state; it performs a step by taking
as input a command and producing an output and a new state. For example, the clients of a distributed banking system might be tellers, and
the state-machine state might consist of the account balances of all users.
A withdrawal would be performed by executing a state machine command
that decreases an account’s balance if and only if the balance is greater than
the amount withdrawn, producing as output the old and new balances.
An implementation that uses a single central server fails if that server
fails. We therefore instead use a collection of servers, each one independently
implementing the state machine. Because the state machine is deterministic,
all the servers will produce the same sequences of states and outputs if they
all execute the same sequence of commands. A client issuing a command
can then use the output generated for it by any server.
To guarantee that all servers execute the same sequence of state machine
commands, we implement a sequence of separate instances of the Paxos
consensus algorithm, the value chosen by the i
th instance being the i
th state
machine command in the sequence. Each server plays all the roles (proposer,
acceptor, and learner) in each instance of the algorithm. For now, I assume
that the set of servers is fixed, so all instances of the consensus algorithm
use the same sets of agents.
In normal operation, a single server is elected to be the leader, which
acts as the distinguished proposer (the only one that tries to issue proposals)
in all instances of the consensus algorithm. Clients send commands to the
leader, who decides where in the sequence each command should appear.
If the leader decides that a certain client command should be the 135th
command, it tries to have that command chosen as the value of the 135th
instance of the consensus algorithm. It will usually succeed. It might fail
because of failures, or because another server also believes itself to be the
leader and has a different idea of what the 135th command should be. But
the consensus algorithm ensures that at most one command can be chosen
as the 135th one.
Key to the efficiency of this approach is that, in the Paxos consensus
algorithm, the value to be proposed is not chosen until phase 2. Recall that,
after completing phase 1 of the proposer’s algorithm, either the value to be
proposed is determined or else the proposer is free to propose any value.
I will now describe how the Paxos state machine implementation works
during normal operation. Later, I will discuss what can go wrong. I consider
what happens when the previous leader has just failed and a new leader has
been selected. (System startup is a special case in which no commands have
yet been proposed.)
The new leader, being a learner in all instances of the consensus algorithm, should know most of the commands that have already been chosen.
Suppose it knows commands 1–134, 138, and 139—that is, the values chosen in instances 1–134, 138, and 139 of the consensus algorithm. (We will
see later how such a gap in the command sequence could arise.) It then
executes phase 1 of instances 135–137 and of all instances greater than 139.
(I describe below how this is done.) Suppose that the outcome of these executions determine the value to be proposed in instances 135 and 140, but
leaves the proposed value unconstrained in all other instances. The leader
then executes phase 2 for instances 135 and 140, thereby choosing commands
135 and 140.
The leader, as well as any other server that learns all the commands
the leader knows, can now execute commands 1–135. However, it can’t
execute commands 138–140, which it also knows, because commands 136
and 137 have yet to be chosen. The leader could take the next two commands
requested by clients to be commands 136 and 137. Instead, we let it fill the
gap immediately by proposing, as commands 136 and 137, a special “noop” command that leaves the state unchanged. (It does this by executing
phase 2 of instances 136 and 137 of the consensus algorithm.) Once these
no-op commands have been chosen, commands 138–140 can be executed.
Commands 1–140 have now been chosen. The leader has also completed
phase 1 for all instances greater than 140 of the consensus algorithm, and it
is free to propose any value in phase 2 of those instances. It assigns command
number 141 to the next command requested by a client, proposing it as the
value in phase 2 of instance 141 of the consensus algorithm. It proposes the
next client command it receives as command 142, and so on.
The leader can propose command 142 before it learns that its proposed
command 141 has been chosen. It’s possible for all the messages it sent
in proposing command 141 to be lost, and for command 142 to be chosen
before any other server has learned what the leader proposed as command
141. When the leader fails to receive the expected response to its phase 2
messages in instance 141, it will retransmit those messages. If all goes well,
its proposed command will be chosen. However, it could fail first, leaving a
gap in the sequence of chosen commands. In general, suppose a leader can
get α commands ahead—that is, it can propose commands i + 1 through
i +α after commands 1 through i are chosen. A gap of up to α−1 commands
could then arise.
A newly chosen leader executes phase 1 for infinitely many instances
of the consensus algorithm—in the scenario above, for instances 135–137
and all instances greater than 139. Using the same proposal number for
all instances, it can do this by sending a single reasonably short message
to the other servers. In phase 1, an acceptor responds with more than a
simple OK only if it has already received a phase 2 message from some
proposer. (In the scenario, this was the case only for instances 135 and
140.) Thus, a server (acting as acceptor) can respond for all instances with
a single reasonably short message. Executing these infinitely many instances
of phase 1 therefore poses no problem.
Since failure of the leader and election of a new one should be rare
events, the effective cost of executing a state machine command—that is, of
achieving consensus on the command/value—is the cost of executing only
phase 2 of the consensus algorithm. It can be shown that phase 2 of the
Paxos consensus algorithm has the minimum possible cost of any algorithm
for reaching agreement in the presence of faults [2]. Hence, the Paxos algorithm is essentially optimal.
This discussion of the normal operation of the system assumes that there
is always a single leader, except for a brief period between the failure of the
current leader and the election of a new one. In abnormal circumstances,
the leader election might fail. If no server is acting as leader, then no new
commands will be proposed. If multiple servers think they are leaders, then
they can all propose values in the same instance of the consensus algorithm, which could prevent any value from being chosen. However, safety is
preserved—two different servers will never disagree on the value chosen as
the i
th state machine command. Election of a single leader is needed only
to ensure progress.
If the set of servers can change, then there must be some way of determining what servers implement what instances of the consensus algorithm.
The easiest way to do this is through the state machine itself. The current
set of servers can be made part of the state and can be changed with ordinary state-machine commands. We can allow a leader to get α commands
ahead by letting the set of servers that execute instance i + α of the consensus algorithm be specified by the state after execution of the i
th state
machine command. This permits a simple implementation of an arbitrarily
sophisticated reconfiguration algorithm.</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <p>[1] Michael J. Fischer, Nancy Lynch, and Michael S. Paterson. Impossibility
of distributed consensus with one faulty process. Journal of the ACM,
32(2):374–382, April 1985.</p> <p>[2] Idit Keidar and Sergio Rajsbaum. On the cost of fault-tolerant consensus
when there are no faults—a tutorial. TechnicalReport MIT-LCS-TR-821,
Laboratory for Computer Science, Massachusetts Institute Technology,
Cambridge, MA, 02139, May 2001. also published in SIGACT News
32(2) (June 2001).</p> <p>[3] Leslie Lamport. The implementation of reliable distributed multiprocess
systems. Computer Networks, 2:95–114, 1978.</p> <p>[4] Leslie Lamport. Time, clocks, and the ordering of events in a distributed
system. Communications of the ACM, 21(7):558–565, July 1978.</p> <p>[5] Leslie Lamport. The part-time parliament. ACM Transactions on Computer Systems, 16(2):133–169, May 1998.</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最近更新时间:</span> <span class="time">7/2/2020, 2:20:00 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/pages/assets/js/app.120c2d51.js" defer></script><script src="/pages/assets/js/7.8965607c.js" defer></script><script src="/pages/assets/js/1.14ff8b03.js" defer></script><script src="/pages/assets/js/47.f2cf7598.js" defer></script>
  </body>
</html>
